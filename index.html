<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
	<title>Assignment 5a</title>
</head>
<style>
	html,
	body {
		height: 100%;
		margin: 0;
	}
	
	.button{
		position: absolute;
		font-size: 20px;
		background-color: #095181;
		padding:5px;
		color: white;
		display: block;
		z-index: 99;
		right: 14%;
		top: 90%;
    }
	.button1{
		right: 6%;
	}
	.button2{
		right: 10%;
	}
	.button:active {
		background-color: #3e8e41;
		box-shadow: 0 5px #666;
		transform: translateY(4px);
	}
	.button:hover {
		background-color: #042135;

	}
	#c {
		width: 100%;
		height: 100%;
		display: block;
	}
	h1{
		font-size: 20px;
		color: white;
		position: absolute;
		display: block;
		z-index: 99;
		right: 54%;
		top: 90%;
	}
	h2{
		font-size: 15px;
		color: white;
		position: absolute;
		display: block;
		z-index: 99;
		left: 5%;
		top: 80%;
	}
	.slider {
		position: absolute;
		display: block;
		z-index: 99;
		right: 28%;
		top: 92%;

		width: 25%;
		height: 15px;
		border-radius: 5px;  
		background: #d3d3d3;
		outline: none;
		opacity: 0.7;
		transition: opacity .2s;
	}

	.slider::-webkit-slider-thumb {
		width: 25px;
		height: 25px;
		border-radius: 50%; 
		background: #04AA6D;
		cursor: pointer;
	}

	.slider::-moz-range-thumb {
		width: 25px;
		height: 25px;
		border-radius: 50%;
		background: #04AA6D;
		cursor: pointer;
	}

</style>

<body> 
	<button id="3rd" class="button button" > Follow Drone</button>
	<!--<button id="1st" class="button button1" >1st Person View</button>-->
	<button id="2nd" class="button button1" >Fly Alone</button>
	<div class="slidecontainer">
		<h1>Speed:</h1>
		<input type="range" min="10" max="100" value="10" class="slider" id="speed"></div>
	<h2>
		<ul>
			<li>WASD move</li>
			<li>R | F Up | Down</li>
			<li>Q | E roll</li>
			<li>up | down pitch</li>
			<li>left | right yaw</li>
			<li>Adjust speed using slider</li>
		</ul> 
	</h2>

	<canvas id="c"></canvas>
</body>
<script type="importmap">{
        "imports": {
            "three": "https://threejs.org/build/three.module.js",
            "three/addons/": "https://threejs.org/examples/jsm/"
        }
        }
    </script>
<script type="module">
	import * as THREE from 'three';
	import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
	import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
	import { Water } from 'three/addons/objects/Water.js';
	import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
	import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
	import { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';
	//import { TransformControls } from 'three/addons/controls/TransformControls.js';
	import { FlyControls } from '/FlyControlsupdate.js';



		//used this resource for button css https://stackoverflow.com/questions/47297794/how-to-overlay-html-text-buttons-on-three-js
		//also got other css stuff from "https://www.w3schools.com/css/css3_buttons.asp"
		
	function main() {
		let speed=10;
		let firstPerson=false;
		let freeze=1;
		document.getElementById('3rd').onclick = function () {freeze=1;};
		//document.getElementById('1st').onclick = function () {firstPerson=true;};
		document.getElementById('2nd').onclick = function () {freeze=-1;};
		var slider = document.getElementById("speed");


		const canvas = document.querySelector('#c');
		//const renderer = new THREE.WebGLRenderer( { antialias: true, canvas } );
		// want to use skybox 
		const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });
		let dHeight=5;

		const fov = 100;
		const aspect = window.innerWidth / window.innerHeight; // the canvas default
		const near = 1;
		const far = 10000;
		const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
		//camera.position.set(-40, 50, 40);
		camera.position.set(-5, 55, 60);
		// using example from "cameras" as a basic guide
		function updateCamera() {
			camera.updateProjectionMatrix();
		}
		
		let controls;
		
		//if(firstPerson==false){
		controls=new OrbitControls(camera, canvas);
		controls.target.set(-5, 55, 60);
		// got help with formatting the camera above the water from this example"https://github.com/mrdoob/three.js/blob/dev/examples/webgl_shaders_ocean.html" 
		//controls.maxPolarAngle = Math.PI * 0.495;
		controls.maxPolarAngle = Math.PI * 0.495;
		controls.maxDistance = 150;
		controls.update();
		//}
		/*
		else{
			// got this idea from this example https://github.com/mrdoob/three.js/blob/master/examples/webgl_geometry_terrain.html
			controls= new FirstPersonControls(camera, renderer.domElement );
			controls.movementSpeed = 100;
			controls.lookSpeed = 0.05;
		}*/

		const clock = new THREE.Clock();

		const scene = new THREE.Scene();
		const waterGeometry = new THREE.PlaneGeometry(16000, 16000);
		let water;
		scene.fog = new THREE.FogExp2( 0x062645, 0.0006 );
		//had to tweak it to be how I wanted, but got a lot of help from this source code https://threejs.org/examples/webgl_shaders_ocean.html
		water = new Water(
			waterGeometry,
			{
				position:0,
				textureWidth: 16000,
				textureHeight: 16000,
				waterNormals: new THREE.TextureLoader().load('waternormals.jpg', function (texture) {

					texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

				}),
				//sunDirection: new THREE.Vector3(),
				sunColor: 0x8B6700,
				waterColor: 0x001861,
				distortionScale: 3.7,
				fog: scene.fog !== undefined
			}
		);

		water.rotation.x = - Math.PI / 2;
		//water.position.y=0;
		scene.add(water);

		//loading in a 3d scenery (specificaly a sky box)
		{
			const loader = new THREE.CubeTextureLoader();
			const texture = loader.load([
				'cubemap/pano_r.jpg', //pos-x
				'cubemap/pano_l.jpg', //neg-x

				'cubemap/pano_u.jpg', //pos-y
				'cubemap/pano_d.jpg', //neg-y

				'cubemap/pano_f.jpg', //pos-z
				'cubemap/pano_b.jpg', //neg-z
				//bfrl 
				//sourced from https://www.utah3d.net/utah-travel/utah-waterways/starry-lake.html
			]);
			scene.background = texture;
		}



		// Create the group -> got idea from this article https://medium.com/@gianluca.lomarco/three-js-object-transforms-74bf439e9e38
		const group = new THREE.Group();

		/*let control = new TransformControls( camera, renderer.domElement );
		control.addEventListener( 'change', render );*/

		const object1=[];
		{// drone obj and mtl. Got from this source https://www.cgtrader.com/items/2480872/download-page
			const mtlLoader = new MTLLoader();
			mtlLoader.load('drone.mtl', (mtl) => {
				mtl.preload();
				const objLoader = new OBJLoader();
				objLoader.setMaterials(mtl);
				objLoader.load('drone.obj', (root) => {
					root.position.y = dHeight;
					root.position.x = -5;
					root.position.z = -10;
					root.scale.set(25, 25, 25);
					//root.rotation.y=(-.6);
					group.add(root);
					//scene.add(root);
					object1.push(root);
				});

			});
		}

		// the 20+ cubes or other shapes
		// here are 12
		let cube,cube1,cube2,cube3,cube4,cube5,cube6,cube7,cube8,cube9,cube10,cube11;
			//creating propellers 
			{
				const cubeSize = .5;
				const cubeGeo = new THREE.BoxGeometry( cubeSize*15, cubeSize, cubeSize );
				const cubeMat = new THREE.MeshPhongMaterial( { color: '#000000' } );
				cube = new THREE.Mesh( cubeGeo, cubeMat );
				cube1 = new THREE.Mesh( cubeGeo, cubeMat );
				cube2 = new THREE.Mesh( cubeGeo, cubeMat );
				cube3 = new THREE.Mesh( cubeGeo, cubeMat );
				cube4 = new THREE.Mesh( cubeGeo, cubeMat );				
				cube5 = new THREE.Mesh( cubeGeo, cubeMat );
				cube6 = new THREE.Mesh( cubeGeo, cubeMat );
				cube7 = new THREE.Mesh( cubeGeo, cubeMat );
				cube8 = new THREE.Mesh( cubeGeo, cubeMat );				
				cube9 = new THREE.Mesh( cubeGeo, cubeMat );
				cube10 = new THREE.Mesh( cubeGeo, cubeMat );
				cube11= new THREE.Mesh( cubeGeo, cubeMat );

				
				cube.position.set(4.6, dHeight+36, -3.5 );
				cube1.position.set(-14.4, dHeight+36, -3.5 );
				cube2.position.set(-14.4, dHeight+36, -17.4 );
				cube3.position.set(4.6, dHeight+36, -17.4 );
				cube4.rotation.y=45;
				cube5.rotation.y=45;
				cube6.rotation.y=45;
				cube7.rotation.y=45;
				cube4.position.set(4.6, dHeight+36, -3.5 );
				cube5.position.set(-14.4, dHeight+36, -3.5 );
				cube6.position.set(-14.4, dHeight+36, -17.4 );
				cube7.position.set(4.6, dHeight+36, -17.4 );

				cube8.rotation.y=90;
				cube9.rotation.y=90;
				cube10.rotation.y=90;
				cube11.rotation.y=90;
				cube8.position.set(4.6, dHeight+36, -3.5 );
				cube9.position.set(-14.4, dHeight+36, -3.5 );
				cube10.position.set(-14.4, dHeight+36, -17.4 );
				cube11.position.set(4.6, dHeight+36, -17.4 );

				//cube.rotation.x = 13;
				
				/*scene.add( cube );
				scene.add( cube1 );
				scene.add( cube2 );
				scene.add( cube3 );
				scene.add( cube4 );
				scene.add( cube5 );
				scene.add( cube6 );
				scene.add( cube7 );
				scene.add( cube8 );
				scene.add( cube9 );
				scene.add( cube10 );
				scene.add( cube11 );*/

				group.add( cube );
				group.add( cube1 );
				group.add( cube2 );
				group.add( cube3 );
				group.add( cube4 );
				group.add( cube5 );
				group.add( cube6 );
				group.add( cube7 );
				group.add( cube8 );
				group.add( cube9 );
				group.add( cube10 );
				group.add( cube11 );
			}
			// creating the rotating camera
			//13 and 14
			let cameraBox,cameraBox2;
			const spheres = []; 
			{
				//added texture to the camera sphere
				let mat;
				const sphereGeo = new THREE.SphereGeometry(.2, 32, 16 );
				const loader = new THREE.TextureLoader();
				loader.load('Camera.png', (texture) => {
					texture.colorSpace = THREE.SRGBColorSpace;
					const material = new THREE.MeshBasicMaterial({
						map: texture,
						});
					cameraBox2 = new THREE.Mesh(sphereGeo, material);
					cameraBox2.position.set(-5.1, dHeight+34.8, -3.4 );
					//scene.add(cameraBox2);
					group.add(cameraBox2);
					spheres.push(cameraBox2);

				});
				const cubeSize = 1.2;
				const cubeGeo = new THREE.BoxGeometry( cubeSize, cubeSize, cubeSize );
				const cubeMat = new THREE.MeshPhongMaterial( { color: '#000000' } );
				//const sphere = new THREE.MeshPhongMaterial(mat);
				cameraBox = new THREE.Mesh( cubeGeo, cubeMat );
				//cameraBox2 = new THREE.Mesh( sphereGeo, sphere );
				cameraBox.position.set(-5.1, dHeight+34.8, -4 );
				
				//scene.add(cameraBox);
				group.add(cameraBox);

			}
			scene.add(group);
			//added buoys 
			// shapes 15-20
			let buoy1,buoy2,buoy3,buoy4,buoy5;
			{
				const sphereGeo = new THREE.SphereGeometry(6, 32, 16 );
				const sphere = new THREE.MeshPhongMaterial( { color: '#e3150e'});
				buoy1 = new THREE.Mesh( sphereGeo, sphere );
				buoy2 = new THREE.Mesh( sphereGeo, sphere );
				buoy3 = new THREE.Mesh( sphereGeo, sphere );
				buoy4 = new THREE.Mesh( sphereGeo, sphere );
				buoy5 = new THREE.Mesh( sphereGeo, sphere );
				buoy1.position.set(400, 400, -3.4 );
				buoy2.position.set(400, 400, 300);
				buoy3.position.set(400, 400, -300 );
				buoy4.position.set(400, 400, -700);
				buoy5.position.set(400, 400, 600 );
				scene.add(buoy1);
				scene.add(buoy2);
				scene.add(buoy3);
				scene.add(buoy4);
				scene.add(buoy5);

			}



		//lighting
		{

			const color = 0xffeca1;
			const intensity = 3;
			//light 1
			const light = new THREE.DirectionalLight(color, intensity);
			const light2 = new THREE.DirectionalLight(0x008080, 3);

			//light 2
			const alight = new THREE.AmbientLight(0x101647, .01);
			//light 3
			const hlight = new THREE.HemisphereLight(0xB1E1FF, 0x101647, .01);
			
			scene.add(alight);
			scene.add(light2);
			scene.add(hlight);
			light.position.set(180, 10, 0);
			light2.position.set(-170, 5, -600);
			light2.target.position.set(-5, 4, 10);
			light.target.position.set(-5, 4, 10);
			scene.add(light);
			scene.add(light.target);

		}

		function resizeRendererToDisplaySize(renderer) {

			const canvas = renderer.domElement;
			const width = canvas.clientWidth;
			const height = canvas.clientHeight;
			const needResize = canvas.width !== width || canvas.height !== height;
			if (needResize) {

				renderer.setSize(width, height, false);

			}

			return needResize;

		}
		var allMoveX=0;
		var allMoveY=0;
		var allMoveZ=2.5;
		var rotateX=0;


		function animationOfDrone(varMove){

			// the only way I could get this to work -> to move the camera
			//let varMove= -.1;
			spheres.forEach( ( cameraBox2, ndx ) => {
				cameraBox2.rotation.y += 0.01;
				cameraBox2.position.x += varMove;
				cameraBox2.position.z += varMove*2.5;
			});
			// moves the drone
			/*
			object1.forEach( ( root, ndx ) => {
				root.position.x += varMove*allMoveX;
				root.position.z += varMove*allMoveZ;
				
				
				if(firstPerson==false){
					if(freeze==1){
						controls.target.set(root.position.x, root.position.y, root.position.z);
						controls.update();
					}
				}
				else{
					controls = new FirstPersonControls(camera, renderer.domElement );
					controls.movementSpeed = 100;
					controls.lookSpeed = 0.05;
				}
			});

			//waterGeometry.translate(0,0,varMove/2.5);
			//waterGeometry.translate(0,-3*varMove,varMove/3);

			cube.position.x += varMove*allMoveX;
			cube.position.z += varMove*allMoveZ;

			cube1.position.x += varMove*allMoveX;
			cube1.position.z += varMove*allMoveZ;

			cube2.position.x += varMove*allMoveX;
			cube2.position.z += varMove*allMoveZ;

			cube3.position.x += varMove*allMoveX;
			cube3.position.z += varMove*allMoveZ;

			cube4.position.x += varMove*allMoveX;			
			cube4.position.z += varMove*allMoveZ;

			cube5.position.x += varMove*allMoveX;
			cube5.position.z += varMove*allMoveZ;

			cube6.position.x += varMove*allMoveX;
			cube6.position.z += varMove*allMoveZ;

			cube7.position.x += varMove*allMoveX;
			cube7.position.z += varMove*allMoveZ;

			cube8.position.x += varMove*allMoveX;			
			cube8.position.z += varMove*allMoveZ;

			cube9.position.x += varMove*allMoveX;			
			cube9.position.z += varMove*allMoveZ;

			cube10.position.x += varMove*allMoveX;
			cube10.position.z += varMove*allMoveZ;

			cube11.position.x += varMove*allMoveX;
			cube11.position.z += varMove*allMoveZ;

			cameraBox.position.x += varMove*allMoveX;
			cameraBox.position.z += varMove*allMoveZ;
			*/
			
			/*if(controls.object.position.y<=2){
				console.log(controls.object.position.y);
				controls.object.position.y==1;
				//control.moveState.pitchDown = 0;
				//control.moveState.down = 0;
			}*/

			control.movementSpeed = slider.value;
			//console.log(freeze);
			
			if(freeze==1){
				controls.target.set(group.position.x, group.position.y, group.position.z);
				camera.rotation.y=group.rotation.y;
				controls.update();
			}

			/*if(firstPerson==false){
					if(freeze==1){
						controls.target.set(group.position.x, group.position.y, group.position.z);
						camera.rotation.y=group.rotation.y;
						controls.update();
						//group.rotation.y=camera.rotation.y;
					}
				}
				else{
					controls = new FirstPersonControls(camera, renderer.domElement );
					controls.movementSpeed = 100;
					controls.lookSpeed = 0.05;
				}
			*/
			/*if(key[2]==true||key[3]==true){
				group.position.x+=varMove*allMoveX;
			}
			if(key[0]==true||key[1]==true){
				group.position.z+=varMove*allMoveZ;
			}
		
			if(keyupRL==true){
				if(group.rotation.z<0){
					group.rotation.z+= .01;
				}
				else if(group.rotation.z>0){
					group.rotation.z-= .01;
				}
			}*/

			//dHeight+=varMove;

		}
		let startOn=0;
		let lClick=false;
		let rClick=false;

		let key=[];
		key[0]=false;//w
		key[1]=false;//s
		key[2]=false;//a
		key[3]=false;//d

		function handleKeyDown(event) {
			console.log(key);
			if (event.keyCode === 87) { //"w"
				allMoveZ=2.5;
				key[0]=true;//w
				startOn=1;
			}
			if (event.keyCode === 83) { //"s"
				allMoveZ=-2.5;
				key[1]=true;//s
				startOn=1;
			}
			if (event.keyCode === 65) { //"a"
				keyupRL=false;
				if(group.rotation.z<.3){
					group.rotation.z+= .09;
				}
				allMoveX=2.5;
				key[2]=true;//a
				rotateX=10;
				startOn=1;
				lClick=true;
			}
			if (event.keyCode === 68) { //"d"
				keyupRL=false;
				if(group.rotation.z>-.3){
					group.rotation.z-= .09;
				}
				allMoveX=-2.5;
				key[3]=true;//w
				rotateX=-10;
				startOn=1;
				rClick=true;
			}
		}
		//scene.add(control);
		let keyupRL=false;
		function handleKeyUp(event) {
			if (event.keyCode === 87) { //"w"
				//control.setMode( 'translate' );
				startOn=0;
				key[0]=false;//w

			}
			if (event.keyCode === 83) { //"s"
				startOn=0;
				key[1]=false;//s
			}
			if (event.keyCode === 65) { //"a"
				keyupRL=true;
				allMoveX=0;
				startOn=0;
				key[2]=false;//a
				lClick=false;
			}
			if (event.keyCode === 68) { //"d"
				allMoveX=0;
				keyupRL=true;
				key[3]=false;//d
				startOn=0;
				rClick=false;
			}
		}

		//figured out an easier way to control the drone

		let control = new FlyControls(group, renderer.domElement );
		control.movementSpeed = slider.value;
		control.domElement = renderer.domElement;
		control.rollSpeed = Math.PI /24;
		control.autoForward = false;
		//control.dragToLook = false;
		control.enabled=true;

		function render() {

			if (resizeRendererToDisplaySize(renderer)) {

				const canvas = renderer.domElement;
				camera.aspect = canvas.clientWidth / canvas.clientHeight;
				camera.updateProjectionMatrix();


			}
			//makes water move.. got help from this example https://github.com/mrdoob/three.js/blob/dev/examples/webgl_shaders_ocean.html
			water.material.uniforms[ 'time' ].value += 1.0 / 60.0;

			//propeller animations (to spin)
			cube.rotation.y += 0.4;
			cube1.rotation.y += 0.4;
			cube2.rotation.y += 0.4;
			cube3.rotation.y += 0.4;
			cube4.rotation.y += 0.4;
			cube5.rotation.y += 0.4;
			cube6.rotation.y += 0.4;
			cube7.rotation.y += 0.4;
			cube8.rotation.y += 0.4;
			cube9.rotation.y += 0.4;
			cube10.rotation.y += 0.4;
			cube11.rotation.y += 0.4;
			cameraBox.rotation.y += 0.01;
						
			//animating moving the drone 
			if(startOn==1){
				animationOfDrone(-1);
			}
			if(startOn==0){
				animationOfDrone(0);
			}
			// got this idea from this example https://github.com/mrdoob/three.js/blob/dev/examples/webgl_shaders_ocean.html
			const time = performance.now() * 0.001;

			//for a more lifelike drone

			//group.position.y=Math.sin( time ) * 1;
			
			//console.log(control.object.position.y);
			if(control.object.position.y<-42){
				control.object.position.y=-41;
				control.dispose();
				if (confirm("You crashed into the water, press ok to start again.")) {
					window.location.reload();
				}
			}
			//console.log(control.object.rotation.z);
			if(control.object.rotation.z==0){
				control.object.rotation.z=0;
			}
			else if(control.object.rotation.z<-0.5){
				control.object.rotation.z=-.5;
			}
			else if(control.object.rotation.z>0.5){
				control.object.rotation.z=.5;
			}


			buoy1.position.y = Math.sin( time ) * 2;
			buoy1.rotation.x = time * 0.5;
			buoy1.rotation.z = time * 0.51;

			buoy2.position.y = Math.sin( time ) * 2;
			buoy2.rotation.x = time * 0.4;
			buoy2.rotation.z = time * 0.41;

			buoy3.position.y = Math.sin( time ) * 2;
			buoy3.rotation.x = time * 0.3;
			buoy3.rotation.z = time * 0.31;

			buoy4.position.y = Math.sin( time ) * 2;
			buoy4.rotation.x = time * 0.5;
			buoy4.rotation.z = time * 0.51;

			buoy4.position.y = Math.sin( time ) * 2;
			buoy4.rotation.x = time * 0.6;
			buoy4.rotation.z = time * 0.61;

			buoy5.position.y = Math.sin( time ) * 2;
			buoy5.rotation.x = time * 0.4;
			buoy5.rotation.z = time * 0.51;

			renderer.render(scene, camera);
			requestAnimationFrame(render);
			
			/*if(firstPerson==true){
				controls.update(clock.getDelta());
			}*/

			//controls.movementSpeed = 0.33;
			control.update(clock.getDelta());

		}
		requestAnimationFrame(render);
	}
	main();
</script>
